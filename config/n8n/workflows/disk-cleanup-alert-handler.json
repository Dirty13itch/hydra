{
  "name": "Disk Space Alert Handler",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "disk-cleanup",
        "options": {}
      },
      "id": "webhook-1",
      "name": "Disk Alert Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [100, 300],
      "webhookId": "disk-cleanup-webhook"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Parse Alertmanager disk alert and determine cleanup level\nconst payload = $input.item.json.body || $input.item.json;\nconst alerts = payload.alerts || [payload];\nconst timestamp = new Date().toISOString();\n\n// Find disk-related alerts\nconst diskAlerts = alerts.filter(a => {\n  const name = a.labels?.alertname || '';\n  return name.includes('Disk') || name.includes('Storage') || name.includes('Filesystem');\n});\n\nif (diskAlerts.length === 0) {\n  return { json: { shouldCleanup: false, reason: 'No disk alerts found' } };\n}\n\n// Get severity from most severe alert\nconst severities = diskAlerts.map(a => a.labels?.severity || 'warning');\nconst hasCritical = severities.includes('critical');\nconst hasWarning = severities.includes('warning');\n\n// Determine cleanup level based on severity\nlet cleanupLevel = 0;\nif (hasCritical) {\n  cleanupLevel = 3; // Aggressive\n} else if (hasWarning) {\n  cleanupLevel = 2; // Moderate\n} else {\n  cleanupLevel = 1; // Light\n}\n\n// Define cleanup targets\nconst cleanupTargets = [\n  { name: 'docker_images', command: 'docker image prune -a --filter \"until=168h\" -f', priority: 1 },\n  { name: 'docker_build_cache', command: 'docker builder prune --filter \"until=168h\" -f', priority: 2 },\n  { name: 'docker_volumes', command: 'docker volume prune -f', priority: 3 },\n  { name: 'loki_old_logs', command: 'find /mnt/user/appdata/hydra-stack/loki/chunks -mtime +30 -delete 2>/dev/null || true', priority: 4 },\n  { name: 'tmp_files', command: 'find /mnt/user/hydra_shared/tmp -mtime +7 -delete 2>/dev/null || true', priority: 5 }\n];\n\nconst targetsToClean = cleanupTargets.filter(t => t.priority <= cleanupLevel);\n\nreturn {\n  json: {\n    timestamp,\n    alertCount: diskAlerts.length,\n    severity: hasCritical ? 'critical' : (hasWarning ? 'warning' : 'info'),\n    cleanupLevel,\n    shouldCleanup: diskAlerts.some(a => a.status === 'firing'),\n    targetsToClean,\n    alerts: diskAlerts.map(a => ({\n      alertname: a.labels?.alertname,\n      severity: a.labels?.severity,\n      status: a.status\n    }))\n  }\n};"
      },
      "id": "code-parse",
      "name": "Parse Alert",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [320, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-cleanup",
              "leftValue": "={{ $json.shouldCleanup }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-cleanup",
      "name": "Should Cleanup?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [540, 300]
    },
    {
      "parameters": {
        "fieldToSplitOut": "targetsToClean",
        "options": {}
      },
      "id": "split-targets",
      "name": "Split Targets",
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [760, 240]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://192.168.1.244:8600/exec",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\"command\": \"{{ $json.command }}\", \"timeout\": 300}",
        "options": {
          "timeout": 300000
        }
      },
      "id": "http-exec",
      "name": "Run Cleanup",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [980, 240],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const target = $('Split Targets').item.json;\nconst result = $input.item.json;\nreturn {\n  json: {\n    action: 'alert_cleanup',\n    target: target.name,\n    command: target.command,\n    success: !result.error,\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "id": "code-result",
      "name": "Log Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 240]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"status\": \"processed\",\n  \"cleanup_initiated\": {{ $('Parse Alert').first().json.shouldCleanup }},\n  \"cleanup_level\": {{ $('Parse Alert').first().json.cleanupLevel }},\n  \"timestamp\": \"{{ $now.toISO() }}\"\n}",
        "options": {}
      },
      "id": "respond-1",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1420, 300]
    }
  ],
  "connections": {
    "Disk Alert Webhook": {
      "main": [[{"node": "Parse Alert", "type": "main", "index": 0}]]
    },
    "Parse Alert": {
      "main": [[{"node": "Should Cleanup?", "type": "main", "index": 0}]]
    },
    "Should Cleanup?": {
      "main": [
        [{"node": "Split Targets", "type": "main", "index": 0}],
        [{"node": "Respond", "type": "main", "index": 0}]
      ]
    },
    "Split Targets": {
      "main": [[{"node": "Run Cleanup", "type": "main", "index": 0}]]
    },
    "Run Cleanup": {
      "main": [[{"node": "Log Result", "type": "main", "index": 0}]]
    },
    "Log Result": {
      "main": [[{"node": "Respond", "type": "main", "index": 0}]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}
